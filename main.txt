//////// NGUYEN MINH TRI - CS2019 - VIETNAMESE-GERMAN UNIVERSITY ////////
//////////// INTRO TO PROGRAMMING 2 - READING ASSIGNMENT 3 //////////////


// Chapter 25: Classes - Inheritance and Polymorphism //

1. Inheritance


Inheritance: A class can be inherited by another class, that is called inheritance.

Ex: class myClass{};
    
    class derivedClass : public myClass{}; // class derivedClass inherites class myClass // 
    
The derived class can access to public or protected members of the original class, but cannot access the private class.
We can also create new members inside the derived class.
The member which is created inside derived class can only be accessed by the derived class, while the inherited members can be accessed by both the base class and the derived one.

Ex: class myClass{
    private:
       int myNum;
    protected:
       char myChar;
    public:
       double myDouble;
    };
    
    
    class derivedClass{
    // myDouble and myChar can be accessed here, but not myNum //
    public:
         float myFloat;
    };
    
    int main(){
        derivedClass a;
        a.myNum = 12;   // Error: No 'myNum' member //
        a.myChar = 'x'; // Error here: not accessible to object //
        a.myDouble = 10.23;
        a.myFloat = 3.14;
        return 0;
    }
    
2. Polymorphism

A pointer to the derived class is compatible with the pointer to the base class since the derived class is also the base class. 
Polymorphism means the object can morph into different types. It can be archived in C++ by virtual function.
Virtual means the function can be overridden/redefined in subsequent derived classes.

Ex1 : 
class baseClass{
    public:
    virtual void dowork(){
        cout << "Hello from base class \n";
    }
};

class derivedClass : public baseClass{
};

int main(){
    baseClass* o = new derivedClass;
    o->dowork(); // If in the derived class there is no dowork function, the pointer o will point into the base class //
    //Print out "Hello from base class" //
    return 0;
}

Ex2 :

class baseClass{
    public:
    virtual void dowork(){
        cout << "Hello from base class \n";
    }
};

class derivedClass : public baseClass{
    public:
    void dowork(){
        cout << "Hello from derived class \n";
    }
};

int main(){
    baseClass* o = new derivedClass;
    o->dowork(); // The pointer o will point into the derived class //
    //Print out "Hello from derived class" //
    return 0;
}

The pure virtual function appears when you define it to be = 0.
The classes that has at least one pure virtual function are called abstract class. It can only be the base class, and in the derived class, it must be redefined.

Ex:
class baseClass{
    public:
    virtual void dowork() = 0;
};

class derivedClass : public baseClass{
    public:
    void dowork(){
         cout << "Hello from derived class \n";
    }
};

int main(){
    baseClass* o = new derivedClass;
    o->dowork();
    //Print out "Hello from base class" //
    return 0;
}


To ensure the proper deallocation of objects accessed through the base class pointer, we use virtual deconstructor.


Ex: class myBaseClass{
    public:
       virtual void dowork() = 0;
       virtual ~myBaseClass(){};
    };
    




// Chapter 26 : Exercises //

#include <iostream>
#include <string>

using namespace std;

class Person{
    private:
    string name;

    public:
    explicit Person(string name){
        this->name = name;
    }
    string getname(){
        return this->name;
    }    
};

class Student : public Person{
    private:
    int semester;

    public:
    Student(string name, int semester) : Person(name){
        this->semester = semester;
    }
    int getsemester(){
        return this->semester;
    }
};

int main(){
    Person a_person("Nguyen Minh Tri");
    cout << a_person.getname() << endl;

    Student a_student("Nguyen Van Nam", 1);
    cout << a_student.getname() << endl;
    cout << a_student.getsemester() << endl;
    return 0;
}




// Chapter 38.1 : Vector //

To create a vector, first, you have to include <vector> library.
To put a new value to the end of the vector, use push_back() function.

Ex: vector<int> a = {1,2,4,5};
    a.push_back(10); // a = {1, 2, 4, 5, 10} //
    
To access the element of the vector, use [index] or at() function (index starts from 0).
To obtain the length of the vector, or the number of elements, use size() function.

Ex: vector <int> a = {1, 2, 3};
    cout << a.size() << endl; // Prints out 3 //
    cout << a[2] << endl; // Prints out 3 //
    cout << a.at(1) << endl; // Prints out 2 //








    
    
    
    
    
    
    
    
    
    
    
    
